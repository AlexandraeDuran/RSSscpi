from RSSscpi.gen import SCPINodeBase
from RSSscpi.gen.SCPI_gen_support import SCPIResponse

import visa

from time import ctime
import timeit
import threading
from multiprocessing import Queue

import re

class VISAEvent(object):
    def __init__(self, duration, stb, esr):
        self.duration = duration
        self.stb = stb
        self.esr = esr


class Instrument(SCPINodeBase):
    _cmd = ""

    def __init__(self, visa_res):
        """
        :type visa_res: pyvisa.resources.tcpip.TCPIPInstrument
        :param visa_res:
        """

        super(Instrument, self).__init__(None)
        self._visa_res = visa_res
        self.command_cnt = 0
        """
        The number of writes/queries performed in total
        """
        self.logger = None
        """
        A file-like object used for logging VISA operations
        """
        self._service_request_callback_handle = None
        self.last_cmd_time = 0

        self._visa_lock = threading.Lock()
        """Lock used to synchronize VISA operations."""

        self.event_queue = Queue()
        """
        Events generated by the VISA library are queued here.
        """

        self.error_queue = Queue()
        """
        Errors fetched from the instrument are queued here.
        """

    def init(self):
        """
        Setup the Service Request handling and turn on event reporting in the instrument.
        """
        # Clear the status register
        # Enable Operation Complete reporting with *OPC
        # Generate a Service Request when the event status register changes, or the error queue is non-empty
        self._write("*CLS;*ESE 127;*SRE 36")

        self._service_request_callback_handle = self._visa_res.install_handler(
            visa.constants.EventType.service_request, self._service_request_handler, 0)
        self._visa_res.enable_event(visa.constants.EventType.service_request, visa.constants.VI_HNDLR)

    # noinspection PyUnusedLocal
    def _service_request_handler(self, session, event_type, context, user_handle):
        """
        This function is invoked as a callback from the VISA library.

        :param session:
        :param event_type:
        :param context:
        :param user_handle:
        :return:
        """
        duration = timeit.default_timer() - self.last_cmd_time
        #print "Handling service request"
        with self._visa_lock:
            stb = self._visa_res.read_stb()  # Read out the SRQ status byte
            if stb & 32:
                esr = self._call_visa(self._visa_res.query, "*ESR?")  # read and reset the event status register
            else:
                esr = 0
            self.log("VISA event: STB: {:08b}, ESR: {:08b}, duration {:.2f} ms".format(stb, int(esr), duration*1e3))
            self.event_queue.put_nowait(VISAEvent(duration, stb, esr))

            if stb & (1 << 2):  # Error queue not empty bit
                self._get_error_queue()
        return visa.constants.VI_SUCCESS

    def _get_error_queue(self):
        err = self._query("SYSTem:ERRor:ALL?")
        for r in re.finditer(r'(-?\d+),"([^"]*)"', str(err)):
            x = (int(r.group(1)), r.group(2))
            print x
            self.error_queue.put_nowait(x)
            self.log("%d %s" % x)

    @staticmethod
    def _build_arg_str(cmd, args):
        if "'string'" in cmd.args:  # string arguments need to be quoted
            ret = []
            for x in args:
                if x is None:
                    continue
                x = str(x)
                try:  # don't quote numbers
                    float(x)
                    if "1" in cmd.args:
                        ret.append(x)
                        continue
                except ValueError:
                    pass
                if x in cmd.args or x[0] == "'" and x[-1] == "'" or x[0] == "#":
                    ret.append(x)
                else:
                    ret.append("'" + x + "'")
        else:
            ret = [str(x) for x in args if x is not None]
        return ", ".join(ret)

    def log(self, line):
        if not self.logger:
            return
        self.logger.write(ctime())
        self.logger.write("\t")
        self.logger.write(line)
        self.logger.write("\n")

    def _call_visa(self, func, arg):
        self.command_cnt += 1
        start = timeit.default_timer()
        try:
            ret = func(arg)
        except object, e:
            self.log("Resource error: " + str(e) + ", " + arg)
            print "Resource error", arg, e
            raise
        self.last_cmd_time = timeit.default_timer()
        elapsed = (self.last_cmd_time - start) * 1e3
        self.log("%.2f ms \t %s" % (elapsed, arg))
        return ret

    def _write(self, cmd_str):
        self._call_visa(self._visa_res.write, cmd_str)

    def write(self, cmd, *args):
        """
        Send a string to the instrument, without reading a respone.

        :param cmd: The SCPI command
        :type cmd: SCPINodeBase
        :param args: Any number of arguments for the command, will be converted with str()
        :rtype: None
        """
        x = cmd.build_cmd() + " " + self._build_arg_str(cmd, args)
        with self._visa_lock:
            self._call_visa(self._visa_res.write, x)

    def _query(self, cmd_str):
        return SCPIResponse(self._call_visa(self._visa_res.query, cmd_str))

    def query(self, cmd, *args):
        """
        Execute a SCPI query

        :param cmd: The SCPI command
        :type cmd: SCPINodeBase
        :param args: A list of arguments for the command, will be converted with str() and joined with ", "
        :return: The response from the pyvisa query
        :rtype: SCPIResponse
        """
        # TODO: add function to read back result later
        x = cmd.build_cmd() + "? " + self._build_arg_str(cmd, args)
        with self._visa_lock:
            return SCPIResponse(self._call_visa(self._visa_res.query, x))

    def preset(self):
        self.RST.w()
